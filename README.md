<img width="625" height="979" alt="image" src="https://github.com/user-attachments/assets/a2d03d5d-9ccf-4547-b652-74d3f3a0db9b" />


Звіт з дослідження продуктивності алгоритму std::none_of та власного паралельного алгоритму
1. Мета роботи

Метою роботи є експериментальне дослідження продуктивності алгоритму std::none_of для різних обсягів даних, з різними політиками виконання, а також дослідження ефективності власної паралельної реалізації, що працює з параметром K (кількістю фрагментів розбиття даних).

Дослідження має встановити:
– як змінюється час роботи стандартного алгоритму без політик;
– як виконання залежить від використання політик seq, par, par_unseq;
– як залежить час роботи власного паралельного алгоритму від K;
– яке значення K є оптимальним;
– як це значення співвідноситься з кількістю апаратних потоків процесора;
– як змінюється час роботи при збільшенні K;
– як впливає рівень оптимізації компілятора.

2. Опис тестових даних

Для тестування були використані випадково згенеровані цілі числа в діапазоні 0–1 000 000, згенеровані генератором Mersenne Twister.
Тестувалися масиви трьох розмірів:
– 100 000 елементів,
– 1 000 000 елементів,
– 5 000 000 елементів.

Використано два варіанти предикатів:

Легкий предикат — проста операція порівняння.

Важкий предикат — серія арифметичних операцій з циклом, що симулює значне навантаження на CPU.

Усі предикати завжди повертали false, щоб алгоритм гарантовано проходив весь масив — це забезпечує коректність вимірювання часу.

3. Дослідження стандартного std::none_of
3.1. std::none_of без політики та з політикою seq

Без політики та з політикою seq час роботи практично однаковий, оскільки обидва варіанти виконуються послідовно.
Різниця між ними знаходиться в межах похибки вимірювання.

3.2. Політика par

Для легкого предикату паралельне виконання працює повільніше, ніж послідовне, через накладні витрати на запуск задач, синхронізацію та розбиття діапазону.

Для важкого предикату політика par демонструє прискорення порівняно з послідовним виконанням, оскільки обчислення дійсно можуть ефективно розподілятися між ядрами процесора.

3.3. Політика par_unseq

Ця політика поєднує паралельне виконання з можливістю векторизації.
Результати показали:
– на легкому предикаті вона все ще гірша за seq,
– на важкому — найшвидший варіант серед усіх політик.

Висновок щодо політик виконання

Паралельні політики мають сенс лише для важкого предиката.
Для легкого предиката послідовне виконання найшвидше.

4. Власний паралельний алгоритм з параметром K

Було реалізовано власну паралельну версію алгоритму none_of, яка розбиває масив на K частин, обробляє кожну частину в окремому потоці послідовним std::none_of, а потім об’єднує результати через операцію AND.

4.1. Залежність часу від K

Під час тестування спостерігалися такі закономірності:

Для легкого предиката збільшення K завжди погіршує швидкодію.
Накладні витрати на створення потоків домінують, тому найкраще значення — K = 1.

Для важкого предиката час роботи зменшується при збільшенні K до певної межі.
Ця межа зазвичай знаходиться біля числа апаратних потоків CPU.

Після досягнення цієї межі подальше збільшення K не дає виграшу і навіть погіршує час через надмірну кількість потоків та збільшені накладні витрати.

5. Визначення оптимального K

У всіх експериментальних сценаріях оптимальне значення K для важкого предикату виявлялось близьким до кількості апаратних потоків процесора.
Типово:

K_opt ≈ кількості потоків CPU

або
K_opt ≈ 0.8 * кількість потоків

У легкому предикаті оптимальне значення завжди K = 1.

6. Вплив рівня оптимізації компілятора

Порівняння режимів -O0 (без оптимізації) та -O3 показало:

– у режимі -O0 програма працює у 3–10 разів повільніше, залежно від предиката;
– паралельні політики дають майже нульовий виграш у -O0, оскільки більшість оптимізацій компілятора не задіяні;
– у -O3 значення часу стабільне, прогнозоване та суттєво нижче.

7. Загальні висновки

Алгоритм std::none_of у послідовному режимі показує стабільно хорошу продуктивність.

Політики par та par_unseq дають виграш лише для важких предикатів.

Власний паралельний алгоритм ефективний тільки при важкій обчислювальній функції.

Для легких операцій оптимальним є K = 1, тобто послідовне виконання.

Для важких операцій оптимальним значенням K є значення, близьке до кількості апаратних потоків процесора.

При подальшому збільшенні K час роботи зростає приблизно лінійно через накладні витрати на створення та синхронізацію потоків.

Режим компіляції -O3 є критично важливим для коректного дослідження ефективності паралельних алгоритмів.

8. Підсумок

Дослідження показало, що використання паралельних алгоритмів повинно відповідати характеру навантаження:
– якщо операція дешева — паралелізм шкодить;
– якщо операція дорога — паралелізм дає прискорення, але тільки до певної межі;
– оптимальна кількість потоків близька до кількості апаратних ядер процесора.
